## ИСПОЛЬЗУЕМ ФУНКЦИЮ READ_TABLE()


* Импорт библиотеки pandas — при выполнении последовательно всех примеров ниже, импорт библиотеки pandas выполняется один раз
```python
import pandas as pd 
# Загружаем данные из файла в переменную, создавая объект DataFrame
countries_data = pd.read_csv('data/countries.csv', sep=';')

# Выгружаем данные из DataFrame в CSV-файл и сохраняем файл в папке data
countries_data.to_csv('data/countries.txt', index=False, sep=' ') 
```
Считаем данные из файла ***countries.txt*** в переменную **txt_df**  (объект DataFrame), применив функцию read_table() с параметрами **sep=' '**  и  **index_col=['country']** (так мы избавимся от столбца с индексом и присвоим названия строкам, используя данные одного из столбцов). Выводим на экран полученный результат:

```python
# Загружаем данные из файла в переменную, создавая объект DataFrame
txt_df = pd.read_table('data/countries.txt', sep=' ', index_col=['country'])
# Выводим содержимое DataFrame на экран
display(txt_df) 
```

## ПРИМЕНЕНИЕ ПАРАМЕТРА HEADER

Используя параметр header, при создании DataFrame мы учитываем наличие/отсутствие строки заголовков в исходном файле данных.

Например, если при считывании данных из ранее сохранённого в папке data файла ***melb_data_ps.csv*** указать значение параметра *header=None*, то первая строка исходного файла не будет восприниматься как строка заголовка и будет отнесена к области данных **DataFrame**:
```python
# Загружаем данные из файла в переменную, создавая объект DataFrame
melb_data = pd.read_csv('data/melb_data_ps.csv', header=None) 
# Выводим содержимое DataFrame на экран
display(melb_data) 
```

## РЕШАЕМ ПРОБЛЕМУ С КОДИРОВКОЙ ИСХОДНЫХ ДАННЫХ

Для решения проблемы выполним следующие действия:

* узнаем, какая кодировка символов используется в считываемом файле (для этого обратимся к субмодулю *chardet.universaldetector* библиотеки [Universal Encoding Detector](https://chardet.readthedocs.io/en/latest/usage.html));
* при считывании файла и создании DataFrame будем использовать параметр *encoding*  —  указывает, какой тип кодировки символов используется в считываемом файле.

Для выполнения кода-примера скачайте файл **ErrorEnCoding.csv** по [ссылке](https://lms.skillfactory.ru/assets/courseware/v1/fcfb039eed06edf73f3e0cf430d4632b/asset-v1:SkillFactory+DST-3.0+28FEB2021+type@asset+block/ErrorEnCoding.csv) и скопируйте его в каталог **data**.

### ЛОКАЛИЗУЕМ ПРОБЛЕМУ

Считываем файл и создаем *DataFrame* без использования параметра *encoding*:

```python
# Считываем данные из файла с неизвестной кодировкой в переменную, создавая объект DataFrame
data=pd.read_csv('data/ErrorEnCoding.csv', header=None, encoding_errors='replace') 
# Выводим содержимое DataFrame на экран
display(data) 
```

### ОПРЕДЕЛЯЕМ КОДИРОВКУ ФАЙЛА

Приведённый ниже код поможет нам определить используемую кодировку в файле, степень достоверности, используемый язык.

```python
# Импортируем субмодуль chardet.universaldetector
from chardet.universaldetector import UniversalDetector 
detector = UniversalDetector()
with open('data/ErrorEnCoding.csv', 'rb') as fh:
    for line in fh:
        detector.feed(line)
        if detector.done:
            break
detector.close()
```

При открытии файла использовалась конструкция with ... as ... (с англ. «с... как...»). Эта конструкция применяется для гарантии того, что критические функции и методы (в данном случае метод .close() закрывает открытый ранее файл) будут выполнены в любом случае.
```python
with open('path/filename') as f: # Открываем файл и связываем его с объектом "f"
    # Работа с файлом...
    # ...не забываем про отступ...
    # ...
# Нет отступа = работа с файлом закончена, файл filename закрыт
```
Для более глубокого знакомства с конструкцией with ... as ... предлагаем вам обратиться к [документации](https://docs.python.org/3/library/ast.html?highlight=#ast.With).

### СЧИТЫВАЕМ ФАЙЛ, УКАЗАВ КОДИРОВКУ
```python
# Создаем DataFrame из файла, явно указав кодировку символов, и выводим его содержимое на экран
data=pd.read_csv('data/ErrorEnCoding.csv',
 encoding='koi8-r',
 header=None )
display(data)
```
Проблема, связанная с кодировкой файла, решена.

## ЧТЕНИЕ ФАЙЛА ПО ССЫЛКЕ, ИСПОЛЬЗУЯ ФУНКЦИЮ READ_TABLE()

Ранее вы уже считывали данные из файла *melb_data.csv*, который находится в свободном доступе в интернете, используя функцию *read_csv()*. Попробуем использовать функцию *read_table()*, указав в качестве разделителя данных запятую — ','.
```python
data = pd.read_table('https://raw.githubusercontent.com/esabunor/MLWorkspace/master/melb_data.csv', sep=',')
display(data)
```

Как видим, функция *read_table()* сработала и с CSV-файлом — достаточно было указать, какой разделитель используется.

## ЧТЕНИЕ/ЗАПИСЬ АРХИВИРОВАННЫХ CSV-ФАЙЛОВ

-> Большие по размеру CSV-файлы для экономии памяти часто «упаковывают» в архив, например zip. 

Механизм, используемый в функции read_csv(), позволяет проводить чтение текстового файла из архива, не распаковывая его. Функция read_csv() сама распознает архив и извлекает из него данные (работает практически со всеми zip-архивами). Есть ограничение — файл в zip-архиве должен быть один (если файлов в архиве несколько, то можно разархивировать файлы и работать с каждым вне архива.)

Используя функцию *read_csv()*, загрузите данные из заархивированного датасета  в переменную data() и выведите её содержимое на экран, используя приведённый ниже код:
```python
data = pd.read_csv('data/students_performance.zip')
display(data)
```
Файл в архиве прочитан без каких-либо проблем, данные из него загружены в переменную data.

В функции *to_csv()* предусмотрен механизм, позволяющий проводить упаковку CSV-файлов в zip-архив. Проделаем обратную операцию — данные из DataFrame data запишем в CSV-файл, упакуем полученный файл в zip-архив «на лету» и сохраним полученный архив в папке data, выполнив следующий код:

```python
# Определяем параметры архивирования — метод сжатия, имя файл в архиве
compression_opts = dict(method='zip', archive_name='out.csv') 
data.to_csv('data/out.zip', index=False, compression=compression_opts)
```

В ходе выполнения кода содержимое DataFrame сохранено в файле out.csv, файл упакован в архив out.zip, а архив записан в каталог data.

## СЧИТЫВАНИЕ ДАННЫХ ИЗ ФАЙЛА EXCEL

Попробуем прочитать наш файл-пример. Для этого передадим в *read_excel()* путь к нему. Чтобы его открыть и сохранить данные в переменную grades, необходимо выполнить следующий код:

```python
grades = pd.read_excel('data/grades.xlsx')
display(grades.head())
```

Так же, как и *read_csv()*, функция *read_excel()* может принимать на вход не только путь к файлу на компьютере, но и интернет-ссылку на него.

## СЧИТЫВАНИЕ ДАННЫХ ИЗ ФАЙЛА EXCEL ПО ССЫЛКЕ

Если файл находится в открытом доступе по ссылке (например, на Google Диске или GitHub), его можно прочитать и из интернета — для этого достаточно в функции *read_excel()* вместо пути до файла указать ссылку на файл. Например:
```python
data = pd.read_excel('https://github.com/asaydn/test/raw/master/january.xlsx')
display(data)
```
Чтобы более подробно ознакомиться с функцией *read_excel()*, предлагаем вам обратиться к [документации](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html).

Следует также учесть, что нормальное поведение pandas — это считывание значений (формулы из Excel-файла не считываются).

Как упоминалось выше, один Excel-файл может включать в себя несколько листов, которые отображаются в разных вкладках (англ. sheet, рус. лист). Например, в нашем файле два листа — Maths и ML.

По умолчанию в DataFrame читается информация из первого листа, однако *read_excel()*  позволяет выбрать, из какого именно листа загружать данные. Сделать это можно с помощью параметра sheet_name (рус. имя_листа). Например, чтобы прочесть данные из второго листа (ML) файла, выполним код:
```python
grades = pd.read_excel('data/grades.xlsx', sheet_name='ML')
display(grades.head())
```

## ВЫГРУЗКА ДАННЫХ ИЗ DATAFRAME В EXCEL-ФАЙЛ

После обработки данных (очистка, создание новых признаков и т. д.) методами и функциями **pandas** мы сталкиваемся с обратной задачей — сохранить данные из **DataFrame** в *Excel*-файл.

Для этого в **pandas** есть функция [to_excel()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_excel.html) (рус. в_Excel), принцип работы которой очень схож с функцией *to_csv()*:

```python
# Сохраняем данные из DataFrame grades в файл grades_new.xlsx в папке data
grades.to_excel('data/grades_new.xlsx')
```

В этом случае будет создан один лист с именем по умолчанию  *"Sheet1"*. Также мы сохраним и индекс — в данных будет находиться лишний столбец. Чтобы создать лист с определённым именем (например, *Example*) и не сохранять индекс, в метод  *to_excel()* необходимо передать параметры *sheet_name='Example'* и *index=False*:
```python
# Сохраняем данные из DataFrame grades в файл grades_new.xlsx (на листе 'Example') в папке data
grades.to_excel('data/grades_new.xlsx', 
sheet_name='Example',
index=False)
```

Чтобы более подробно ознакомиться с функцией to_excel(), предлагаем вам обратиться к [документации](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_excel.html).