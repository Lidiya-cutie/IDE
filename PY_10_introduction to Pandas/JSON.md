# JSON

-> JSON — это простой, структурированный формат обмена данными, основанный на использовании текста.

Аббревиатура **JSON** расшифровывается как JavaScript Object Notation, в переводе на русский — система обозначения/записи объектов JavaScript. Несмотря на то, что JSON изначально основывался на языке программирования JavaScript, он является общепризнанным форматом обмена данными, и многие языки программирования, включая Python, содержат эффективные инструменты для работы с ним.
## МОДУЛИ ДЛЯ РАБОТЫ С JSON

Для работы с данными в формате *JSON* используется модуль json из стандартной библиотеки языка *Python*, который необходимо будет загрузить перед началом работы с данными, выполнив следующую команду:

```python
# Импортируем модуль json
import json 
```
Также нам может быть полезен модуль *pprint*  (от англ. *pretty print*, рус. *красивый вывод на экран*), а точнее — встроенная в него одноимённая функция *pprint()*, с помощью которой можно красиво выводить на экран содержимое *JSON*-файла. Для загрузки нужной нам функции перед началом работы выполним следующий код:

```python
from pprint import pprint
```

## КАК ВЫГЛЯДИТ JSON-ФАЙЛ?

Информация в формате JSON представляет собой (в закодированном виде) одну из двух структур:

* набор пар **"ключ-значение"**, где ключ — это всегда **строковая величина** (в *Python* такая структура преобразуется в словарь);
* упорядоченный набор значений (при чтении *JSON*-файла в *Python* эта структура будет преобразована в список).

## ОТКРЫВАЕМ JSON-ФАЙЛ

-> Чтобы перевести данные из формата *JSON* в формат, который можно обрабатывать инструментами *Python*, необходимо выполнить процедуру, которая называется **десериализация** (декодирование данных). Обратный процесс, связанный с переводом структур данных *Python* в формат *JSON*, называется **сериализацией**.

Для выполнения **десериализации** мы воспользуемся методом *load()* (от англ. загрузить) модуля *json*, который принимает на вход ссылку на открытый *JSON*-файл:

```python
# Открываем файл и связываем его с объектом "f"
with open('recipes.json') as f:
    # Загружаем содержимое открытого файла в переменную recipes
    recipes = json.load(f)
```

Отлично! Теперь содержимое нашего файла загружено в переменную *recipes*. Давайте выведем его на экран с помощью функции *pprint()* из одноимённого модуля:

```pithon
# Выводим на экран содержимое переменной recipes, используя функция pprint()
pprint(recipes)
```

Целиком код выглядит следующим образом:
```python
import json
from pprint import pprint
with open('recipes.json') as f:
    recipes = json.load(f)
pprint(recipes)
```

## ИЗВЛЕКАЕМ ДАННЫЕ ИЗ JSON-ФАЙЛА
После того как мы провели **десериализацию** данных из *JSON*-файла, мы можем работать с полученным объектом как с обычными списками и словарями. Единственное отличие этой работы от манипуляций с привычными нам списками и словарями заключается в том, что данных теперь больше и они помещены внутрь структуры с большим количеством уровней вложенности.

Давайте выясним некоторые детали о блюде, которое записано первым в списке блюд. Его индекс — 0, и информация о нём хранится в словаре. Чтобы узнать *ID* этого блюда, мы можем обратиться к соответствующему **ключу** словаря, выполнив следующий код:

```python
import json # Импортируем модуль json
from pprint import pprint # Импортируем функцию pprint()
with open('recipes.json') as f: # Открываем файл и связываем его с объектом "f"
    recipes = json.load(f) # Загружаем содержимое открытого файла в переменную recipes
recipes[0]['id']

# 10259 - результат вывода кода
```
Аналогичным образом, для получения списка ингредиентов первого блюда в списке мы можем использовать тот же код, заменив в нём ключ *'id'* на *'ingredients'*. 

```python
import json # Импортируем модуль json
from pprint import pprint # Импортируем функцию pprint()
with open('recipes.json') as f: # Открываем файл и связываем его с объектом "f"
    recipes = json.load(f) # Загружаем содержимое открытого файла в переменную recipes
recipes[0]['ingredients']

#['romaine lettuce',
# 'black olives',
# 'grape tomatoes',
# 'garlic',
# 'pepper',
# 'purple onion',
# 'seasoning',
# 'garbanzo beans',
# 'feta cheese crumbles'] - результат вывода кода
```
Мы также можем извлечь информацию о конкретном блюде по его *ID*. Для этого необходимо с помощью цикла, например *for*, перебрать все элементы списка, проверяя ключ *'id'*,  и извлечь нужную информацию, когда мы наконец найдем нужное блюдо.

```python
import json # Импортируем модуль json
from pprint import pprint # Импортируем функцию pprint()
with open('recipes.json') as f: # Открываем файл и связываем его с объектом "f"
    recipes = json.load(f) # Загружаем содержимое открытого файла в переменную recipes
len(recipes[0]['ingredients']) # Определяем количество ингредиентов в составе первого блюда/рецепта

# 9 - результат вывода кода
```
Чтобы узнать количество ингридиентов, используем функцию *len()*.
```python
import json # Импортируем модуль json
from pprint import pprint # Импортируем функцию pprint()
with open('recipes.json') as f: # Открываем файл и связываем его с объектом "f"
    recipes = json.load(f) # Загружаем содержимое открытого файла в переменную recipes
for recipe in recipes: # начинаем перебор всех блюд входящих в список
    if recipe['id'] == 13121: # если id текущего блюда равен заданному для поиска
        print(recipe['cuisine']) # выводим на экран наименование кухни, к которой относится блюдо
        break # прерываем выполнение цикла, т.к. нужное блюдо найдено

# thai - результат вывода кода
```

```python
# Используя список
import json # Импортируем модуль json
from pprint import pprint # Импортируем функцию pprint()
with open('recipes.json') as f: # Открываем файл и связываем его с объектом "f"
    recipes = json.load(f) # Загружаем содержимое открытого файла в переменную recipes
cuisines = [] # создаём пустой список для хранения уникальных значений кухонь
for recipe in recipes:  # начинаем перебор всех рецептов
    if not(recipe['cuisine'] in cuisines): # если тип кухни текущего блюда ещё не встречался
        cuisines.append(recipe['cuisine']) # добавляем его к списку cuisines
len(cuisines) # Выводим на экран полученное значение

# 20 - результат вывода кода
```

```python
# Используя множество
import json # Импортируем модуль json
from pprint import pprint # Импортируем функцию pprint()
with open('recipes.json') as f: # Открываем файл и связываем его с объектом "f"
    recipes = json.load(f) # Загружаем содержимое открытого файла в переменную recipes
cuisines = set() # создаём пустое множество для хранения уникальных значений кухонь
for recipe in recipes: # начинаем перебор всех рецептов
    cuisines.add(recipe['cuisine']) # добавляем название типа кухни к множеству
len(cuisines) # Выводим на экран полученное значение

# 20 - результат вывода кода
```
Для того, чтобы узнать какой из национальных кухонь принадлежит самое большое количество рецептов, нам потребуется:

* Импортировать необходимые модули.
* Загрузить содержимое открытого файла в переменную recipes.
* Создать список уникальных значений кухонь.
* Создать словарь для хранения информации о количестве рецептов в каждой кухне (ключ cuisine, значение — количество рецептов) и заполняем.
* Определить ключ с максимальным значением количества.

В итоге получаем следующий код:
```python
# Импортируем модуль json
import json 
# Импортируем функцию pprint()
from pprint import pprint 
# Открываем файл и связываем его с объектом "f"
with open ('recipes.json') as f:
    # Загружаем содержимое открытого файла в переменную recipes
    recipes = json.load(f)
# Создаём пустой список для хранения уникальных значений кухонь
cuisines = []
# Начинаем перебор всех рецептов
for recipe in recipes:
    # Если тип кухни текущего блюда ещё не встречался
    if not(recipe['cuisine'] in cuisines):
        # Добавляем его к списку cuisines
        cuisines.append(recipe['cuisine'])
 # Создаём пустой словарь для хранения информации об количествах рецептов в каждой кухне
valreccuisine = {}
# Перебираем список кухонь
for item in cuisines:
    # Добавляем в словарь ключ, соответствующий очередной кухне
    valreccuisine[item] = 0
# Перебираем список рецептов
for recipe in recipes:
    # Увеличиваем значение нужного ключа в словаре на 1
    valreccuisine[recipe['cuisine']] +=1 

# Извлекаем значения для всех ключей используя метод get(), выбираем самое максимальное значение (при наличии одинаковых значений будет выбрано первое в словаре) и выводим на экран ключ максимального значения
print(max(valreccuisine,key=valreccuisine.get))

# italian - результат вывода кода
```

## ИЗ JSON В PANDAS

-> Как вы помните, после **десериализации** наши данные были преобразованы в список, элементами которого являются вложенные словари, содержащие по три пары "ключ-значение". 

Поскольку структура всех вложенных словарей одинакова, мы можем создать DataFrame на основе списка, не проводя с ним никаких дополнительных манипуляций:

```python
# Импортируем модуль json
import json 
# Импортируем функцию pprint()
fron pprint import pprint
# Импортируем модуль pandas
import pandas as pd

# Открываем файл и связываем его с объектом "f"
with open('recipes.json') as f:
    # Загружаем содержимое открытого файла в переменную recipes
    recipes = json.load(f)
# Создаём объект DataFrame из списка recipes
df = pd.DataFrame(recipes)
# Выводим на экран первые строки полученного DataFrame
display(df.head())
```

Для непосредственного считывания содержимого файла *recipes.json* в переменную ***df*** (объект *DataFrame*) используйте функцию *read_json()* (с англ. читать_*json*).

```python
# Импортируем модуль pandas
import pandas as pd 
# Создаём объект DataFrame, загружая содержимое файла recipes.json
df = pd.read_json('recipes.json')
# Выводим на экран первые строки полученного DataFrame
display(df.head())
```
Для более подробного ознакомления с функцией  *read_json()* предлагаем вам обратиться к [документации](https://pandas.pydata.org/pandas-docs/version/1.1.3/reference/api/pandas.read_json.html).


Работу над преобразованием DataFrame начнём с создания и заполнения столбцов, содержащих сведения о наличии или отсутствии каждого ингредиента в рецепте. Процесс заполнения выполним в два этапа:

* Создадим функцию для заполнения значения в каждой ячейке. Функция будет проверять наличие конкретного ингредиента в столбце *ingredients* для текущего блюда и возвращать 1, если ингредиент есть в рецепте, и 0, если он отсутствует.
* Организуем цикл, в котором будем перебирать наименования всех ингредиентов DataFrame (для этого потребуется создать реестр, то есть некий список, который содержит уникальные наименования ингредиентов). Для каждого ингредиента создадим в DataFrame столбец с соответствующим названием и заполним его единицами и нулями, применив к DataFrame, а точнее к столбцу ingredients функцию, созданную нами на предыдущем этапе.

```python
# Импортируем модуль json
import json
# Импортируем функцию pprint()
from pprint import pprint
# Импортируем модуль pandas
import pandas as pd

# Открываем файл и связываем его с объектом "f"
with open('recipes.json') as f:
    # Загружаем содержимое открытого файла в переменную recipes
    recipes = json.load(f)

# Создаем пустое множество для хранения реестра уникальных ингредиентов    
all_ingredients = set()
# Начинаем перебор всех блюд входящих в список
for recipe in pecipes:
    # Начинаем перебор всех ингредиентов входящих в состав текущего блюда
    for igredient in recipe['ingredients']:
        # Добавляем уникальный ингредиент в реестр
        all_ingredients.add(ingredient)

# Выводим на экран количество уникальных ингредиентов из реестра
display(len(all_ingredients))
```

Теперь определим функцию *contains()*, с помощью которой мы будем проверять наличие конкретного ингредиента *ingredient_name* в рецепте текущего блюда, который представлен списком *ingredient_list* (значение в ячейке столбца *ingredients* текущего рецепта).

Функция будет возвращать 1, если ингредиент есть в рецепте, и 0, если он отсутствует:

```python
# Определяем имя функции и передаваемые аргументы
def contains(ingredient_list):
    # Если ингредиент есть в текущем блюде,
    if ingredient_name in ingredient_list:
        # возвращаем значение 1
        return 1
    # Если ингредиента нет в текущем блюде,
    else:
        # возвращаем значение 0
        return 0
```
Отлично! Осталось лишь перебрать все ингредиенты из ранее созданного реестра *all_ingredients* с помощью цикла  *for*  и создать в *DataFrame* столбец с соответствующим названием, заполнив его единицами и нулями. Для этого применим к *DataFrame*, а точнее, к столбцу *ingredients* функцию *contains()*.

```python
# Последовательно перебираем ингредиенты в реестре all_ingredients
for ingredient_name in all_ingredients:
    # В DataFrame cоздаем столбец с именем текущего ингредиента и заполняем его единицами и нулями, используя ранее созданную функцию contains
    df[ingredient_name] = df['ingredients'].apply(contains)
```

В завершение изменим значение столбца ingredients — вместо списка ингредиентов в каждом рецепте заполним столбец данными о количестве ингредиентов в нём:

```python
# Заменяем список ингредиентов в рецепте на их количество 
df['ingredients'] = df['ingredients'].apply(len)
# Выводим содержимое полученного DataFrame на экран
display(df)
```

В итоге код будет выглядеть так:

```python
# Импортируем модуль json
import json
# Импортируем функцию pprint()
from pprint import pprint
# Импортируем модуль pandas
import pandas as pd

with open('recipes.json') as f: # Открываем файл и связываем его с объектом "f"
    recipes = json.load(f) # Загружаем содержимое открытого файла в переменную recipes

all_ingredients=set() # Создаем пустое множество для хранения реестра уникальных ингредиентов
for recipe in recipes: # Начинаем перебор всех блюд входящих в список
    for ingredient in recipe['ingredients']: # Начинаем перебор всех ингредиентов входящих в состав текущего блюда
        all_ingredients.add(ingredient ) # Добавляем уникальный ингредиент в реестр
    
df = pd.DataFrame(recipes) # Создаем объект DataFrame из списка recipes

def contains(ingredient_list): # Определяем имя функции и передаваемые аргументы
    if ingredient_name in ingredient_list: # Если ингредиент есть в текущем блюде,
        return 1 # возвращаем значение 1
    else: # Если ингредиента нет в текущем блюде,
        return 0 # возвращаем значение 0
            
for ingredient_name in all_ingredients: # Последовательно перебираем ингредиенты в реестре all_ingredients
    df[ingredient_name] = df['ingredients'].apply(contains) # В DataFrame cоздаем столбец с именем текущего ингредиента и заполняем его единицами и нулями, используя ранее созданную функцию contains

df['ingredients'] = df['ingredients'].apply(len) # Заменяем список ингредиентов в рецепте, на их количество
```

Напишите код для создания списка ids всех блюд, представленных в датафрейме. Нужны только уникальные значения.

Порядок id должен совпадать с тем, как они расположены в исходном датафрейме.

```python
# Возможный вариант решения:
import pandas as pd

df = pd.read_csv('recipes.csv') # Читаем содержмиое файла и создаем объект df
ids = list(df['id'].unique()) # Создаем список уникальных значений id блюд
```

## СОХРАНЯЕМ DATAFRAME В CSV-ФАЙЛЕ

Eсли мы планируем продолжать работать с DataFrame, созданными на основе данных, которые мы получили в JSON-формате, то полезно будет сохранить промежуточный DataFrame в виде CSV-файла. Для выполнения этой операции воспользуемся известной нам в Pandas функцией to_csv():

```python
df.to_csv('recipes.csv', index = False)
```