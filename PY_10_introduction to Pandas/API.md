# Работа с API

**API** — это специальные разделы сайта, где информацию можно получать без разметки, а формат запросов и ответов зафиксирован. *API* созданы для того, чтобы облегчить взаимодействие с сайтом для сторонних разработчиков.

Рассмотрим на примере социальной сети ВКонтакте особенности *API*, характерные для более крупных сайтов.

## КЛЮЧ АВТОРИЗАЦИИ

Для того чтобы начать работать с *API*, обычно необходимо получить сервисный ключ авторизации — **токен**.

**Токен** — это средство идентификации пользователя или отдельного сеанса работы в компьютерных сетях и приложениях. Различают **программные** и **аппаратные** токены.
Мы будем использовать программный токен, который обычно представляет собой зашифрованную последовательность символов, позволяющую точно идентифицировать объект и определить уровень его привилегий. Он генерируется системой авторизации и привязывается к конкретному сеансу работы, клиенту сети или пакету данных.

Сначала рассмотрим работу *API* на простом примере, на основе которого работают многие системы.

Сделаем наш первый запрос из браузера.

Перейдите по следующей ниже ссылке в браузере, подставив вместо слова **TOKEN** ваш персональный сервисный ключ доступа (токен), полученный на предыдущем шаге:
```python
https://api.vk.com/method/users.get?user_id=1&v=5.95&access_token=TOKEN
```
Результат:

**{"response":[{"id":1,"first_name":"Павел","last_name":"Дуров","can_access_closed":true,"is_closed":false}]}**

Итак, мы сделали GET-запрос к API ВКонтакте, который состоит из следующих элементов:

* _https://api.vk.com/method_ — домен и *URL* запроса *API*; обычно не меняется;
* _users.get_ — название метода, который отдаёт определённый отчёт, в нашем случае это метод для получения информации о пользователе;
* _user_id_ и _v_ — параметры запроса: идентификатор пользователя, о котором хотим получить информацию (в нашем примере мы запрашиваем информацию о первом пользователе), и номер версии *API*;
* _token_ — токен, который выдаётся только пользователям, имеющим право просматривать определённые данные, например показания счётчиков Яндекс. Метрики вашего проекта; на все остальные запросы без корректного токена система отвечает отказом.

```python
# Добавим к запросу дату рождения и пол (согласно документации, эти параметры надо перечислять в поле fields):
https://api.vk.com/method/users.get?user_id=1&v=5.95&fields=sex,bdate&access_token=TOKEN

# {"response":[{"id":1,"bdate":"10.10.1984","sex":2,"first_name":"Павел","last_name":"Дуров","can_access_closed":true,"is_closed":false}]} - результат выполнения кода
```
**Примечание**: значение 2 у параметра *sex* означает мужской пол.

До этого момента мы делали запросы в браузере — теперь давайте выполним запросы из кода.

## ЗАПРОС К API ИЗ КОДА
Продолжаем пользоваться всё той же библиотекой *requests*.
```python
# Импортируем модуль requests
import requests
# Указываем свой (!!!) сервисный токен
token = '...'
# Указываем адрес страницы к которой делаем запрос
url = 'https://api.vk.com/method/users.get'
# Перечисляем параметры нашего запроса в словаре params
params = {'user_id': 1, 'v': 5.95, 'fields': 'sex,bdate', 'access_token': token, 'lang': 'ru'}
# Отправляем запрос
response = requests.get(url, params=params)
# Выводим текст ответа на экран
print(response.text)

# {"response":[{"id":1,"bdate":"10.10.1984","sex":2,"first_name":"Павел","last_name":"Дуров","can_access_closed":true,"is_closed":false}]} - результат выполнения кода
```
Мы получили строку в *JSON*-формате, которую можно преобразовать в словарь с помощью метода *json()*, после чего можно с лёгкостью обращаться к различным полям.

Словари нагляднее выводить с помощью функции *pprint()*:
```python
# Импортируем функцию pprint()
from pprint import pprint
# Выводим содержимое словаря, содержащего ответ, на экран
pprint(response.json())
```
По ключу *response* мы можем получить список, в котором хранятся словари, содержащие информацию о запрошенных нами пользователях. Мы запросили информацию лишь об одном из них, поэтому список содержит только один элемент. Извлечём его:
```python
# Извлекаем из словаря по ключу response информацию о первом пользователе
user = response.json()['response'][0]
# Выводим дату рождения первого пользователя на экран
print(user['bdate'])
# 10.10.1984 - результат выполнения кода
```
Метод *users.get()* позволяет запрашивать информацию о множестве (до 1 000) пользователей одновременно. Для этого нужно использовать параметр *user_ids* и передавать *id* через запятую в строковом формате. Например, чтобы получить информацию о пользователях с *id=1, id=2, id=3*, необходимо передать значение параметра *user_ids='1,2,3'*.

Попробуем это сделать:
```python
# Формируем строку, содержащую информацию о поле id первых трёх пользователей
ids = ','.join(map(str,range(1, 4)))
# Формируем строку параметров
params = {'user_id': ids, 'v': 5.95, 'fields': 'bdate', 'access_token': token, 'lang': 'ru'}
# Посылаем запрос, полученный ответ в формате JSON-строки преобразуем в словарь и выводим на экран его содержимое, используя функцию pprint()
pprint(requests.get(url, params=params).json())
```
Используя *API*, определите долю женщин (*sex=1*) среди пользователей с *id* от 1 до 500. Иногда будут попадаться пользователи, у которых пол не указан (*sex=0*), — таких пользователей не нужно учитывать в общем числе.

В ответе укажите число, округлив до двух знаков после точки-разделителя, например, *0.55*.
```python
import requests
# token = '...'
url = 'https://api.vk.com/method/users.get'
ids = ','.join(map(str, range(1, 501)))
params = {'user_ids': ids, 'v': 5.95, 'fields': 'sex.bdate', 'fields': 'sex', 'access_token': token, 'lang': 'ru'}
response = requests.get(url, params=params),json()['response']
men=women=0
for elem in response:
    if elem['sex'] == 2:
        men += 1
    elif elem['sex'] == 1:
        women += 1
    else:
        continue
print(round(women/(men + women), 2))
```
## СБОР ИНФОРМАЦИИ ИЗ ГРУПП
Теперь мы научимся считать произвольные метрики групп, собирая данные из API и работая с двумя ограничениями, которые свойственны практически всем системам:

* ограничение на количество вызовов в единицу времени;
* ограничение на количество выгружаемых строк за один запрос.

Давайте рассмотрим, как работать с этими ограничениями на примере выгрузки списка пользователей группы [https://vk.com/vk](https://vk.com/vk) социальной сети ВКонтакте.

Обратимся к [документации](https://vk.com/dev/groups), чтобы узнать, какие методы нам доступны для групп, — для получения списка пользователей группы доступен метод [groups.getMembers](https://vk.com/dev/groups.getMembers).

Согласно документации, обязательным параметром данного метода является *group_id* — идентификатор, или короткое имя, группы. В нашем случае это vk: [https://vk.com/vk](https://vk.com/vk). Протестируем, как работает метод в самом простом случае, — получим *id* участников группы:
```python
import requests
token = '...'
url = 'https://api.vk.com/method/groups.getMembers'
params = {'group_id': 'vk', 'v': 5.95, 'access_token': token}
response = requests.get(url, params=params)
data = response.json()
print(data)

# {'response': {'count': 13187448, 'items': [6, 19, 47, 54, 79;
```
По ключу *count* мы можем получить общее число участников группы, а список по ключу *items* хранит их *id*:
```python
# Выводим на экран количество элементов словаря
print(len(data['response']['items']))

# 1000 - результат выпполнения кода
```
Мы видим, что всего пользователей в группе больше 11 миллионов, а получили мы только первую тысячу пользователей группы. По информации, указанной в документации о параметре count, это максимум, который может отдать *API* за один раз.

Для получения следующей тысячи пользователей можно воспользоваться параметром *offset* (с англ. смещение), который передвинет начало отсчёта. Для выгрузки всех пользователей группы будем в цикле выгружать по 1000 пользователей (count будет всегда равен 1000), увеличивая смещение *offset* на величину count.

Для тренировки напишем цикл выгрузки первых 20 пользователей со значением *count=5*. Иными словами, мы будем выгружать по пять пользователей за запрос до тех пор, пока не получим информацию о 20 пользователях.

Давайте выведем на экран первые 20 пользователей из нашей первой попытки получить информацию о 1000 пользователей, чтобы мы могли сверить результат выгрузки из 20 пользователей:
```python
# Загружаем в переменную информацию об id первых 20 пользователей в виде списка
users_for_checking = data['response']['items'][:20]
# Выводим перечень id первых 20 пользователей
print(users_for_checking)

# [6, 19, 47, 54, 79, 177, 198, 212, 219, 239, 243, 345, 407, 421, 450, 467, 485, 510, 550, 619] - результат выпполнения кода
```
Теперь используем count и *offset*, чтобы получить те же *id* по пять за раз:
```python
# Импортируем модуль requests
import requests
# Указываем свой сервисный токен
token = '...'
# Указываем адрес обращения
url = 'https://api.vk.com/method/groups.getMembers'
count = 5
offset = 0
user_id = []
max_count = 20
while offset < max_count:
    # Будем выгружать по count=5 пользователей, 
    # начиная с того места, где закончили на предыдущей итерации (offset) 
    print(f'Выгружаю {count} пользователей с offset = {offset}')
    params = {'group_id': 'vk', 'v': 5.95, 'count': count, 'offset': offset, 'access_token': token}
    response = requests.get(url. params=params)
    data = response.json()
    user_ids += data['response']['items']
    # Увеличиваем смещение на количество строк, которое мы уже выгрузили
    offset += count 
print(user_ids)

# Выгружаю 5 пользователей с offset = 0
# Выгружаю 5 пользователей с offset = 5
# Выгружаю 5 пользователей с offset = 10
# Выгружаю 5 пользователей с offset = 15
# [6, 19, 47, 54, 79, 177, 198, 212, 219, 239, 243, 345, 407, 421, 450, 467, 485, 510, 550, 619] - результат выпполнения кода
```
Сравним списки, полученные двумя способами:

```python
print(user_ids == users_for_checking) 
# True - результат выпполнения кода
```
Так как результат сравнения — True, списки идентичны. Значит, второй способ работает корректно. Теперь мы можем получить данные обо всех пользователях, выставив *count = 1000* и *max_count = data['response']['count']*.

## ОГРАНИЧЕНИЕ ПО ЧАСТОТЕ ЗАПРОСОВ

Чтобы не следить за частотой отправки запросов с секундомером в руках, мы можем после каждого запроса делать паузу. В этом случае, даже если код будет выполняться на самом быстром компьютере, мы не нарушим установленное ограничение, так как периодичность отправки запросов будет искусственно замедлена.

Воспользуемся библиотекой *time* и методом *sleep*, с помощью которого мы можем добавить паузу, например в 0.5 секунд, после каждого запроса:
```python
import requests
import time
token = '...'
url = 'https://api.vk.com/method/groups.getMembers'
count = 1000
offset = 0
user_ids = []
while offset < 5000:
    params = {'group_id': 'vk', 'v': 5.95, 'count': count, 'offset': offset,
     'access_token': token}
    response = requests.get(url, params = params)
    data = response.json()
    user_ids += data['response']['items']
    offset += count
    print(f'Ожидаю 0.5 секунды...')
    teme.sleep(0.5)
print(f'Цикл завершен, offset = {}')

# Ожидаю 0.5 секунды...
# Ожидаю 0.5 секунды...
# Ожидаю 0.5 секунды...
# Ожидаю 0.5 секунды...
# Ожидаю 0.5 секунды...
# Цикл завершен, offset = 5000 - результат выпполнения кода
```
## ЛАЙКИ, РЕПОСТЫ И КОММЕНТАРИИ
Через API новостной ленты ВКонтакте мы можем получить информацию о взаимодействии с сообщениями в ленте.

Для примера продолжим работать с группой [https://vk.com/vk](https://vk.com/vk) и рассмотрим последние 100 сообщений в новостной ленте.

Для получения информации о сообщениях на стене в *API* ВКонтакте предусмотрен метод *[wall.get](https://vk.com/dev/wall.get)*. Применим его:
```python
# Импортируем модуль requests
import requests
# Импортируем функцию pprint()
from pprint import pprint
# Указываем свой сервисный токен
token = '...'
# Указываем адрес страницы, к которой делаем запрос
url = 'https://api.vk.com/method/wall.get'
params = {'domain': 'vk',
'filter': 'owner', 'count': 1000, 'offset': 0, 'access_token': token, 'v': 5.95}
response = requests.get(url, params=params)
pprint(response.json())
```
Посмотрим на количество результатов:
```python
len(response.json()['response']['items'])
## 100 - 
```
Посмотрим на информацию об отдельном сообщении:
```python
response.json()['response']['items'][0] 
```
В полях *comments*, *likes* и *reposts* содержится статистика по взаимодействию с сообщением пользователей (на момент получения информации) — число комментариев, лайков и репостов.

Давайте соберём итоговую статистику для последних десяти непустых сообщений в словарь *stats*. В качестве ключа будем использовать начало сообщения (если начало сообщения пустое, то информацию о таком сообщении проигнорируем), в качестве значения — список с тремя интересующими нас метриками и временем публикации (комментарии, лайки, репосты, дата публикации):
```python
stats = {}
count_post = 0
for record in response.json()['response']['items'][:]:
    title = record['text'][:30]
    if title:
        stats[title] = [record['comments']['count'],record['likes']['count'], record['reposts']['count'], record['date']]
        count_post += 1
    if count_post < 10:
        continue
    else:
        break
pprint(stats)
```
Если вы размещаете рекламу во ВКонтакте, то можно выгружать всю статистику через *[ads API](https://vk.com/dev/ads)*.

Полный список методов ВКонтакте можно посмотреть в [документации](https://vk.com/dev/methods).

*API* для разработчиков предоставляют и многие другие платформы. Вот список, пожалуй, самых популярных из них:

* [Google Maps API](https://developers.google.com/maps/)
* [YouTube API](https://developers.google.com/youtube/)
* [Twitter API](https://dev.twitter.com/overview/documentation)
* [Facebook API](https://developers.facebook.com/docs/)

Информацию о сторонних *API* можно найти в *[каталоге Web API](https://www.programmableweb.com/category/all/apis)*. Также можно воспользоваться интернет-поиском, указав в строке поиска, например, *«курсы валют API»* или *«прогноз погоды api»*, — среди первых результатов выдачи чаще всего с лёгкостью можно найти ссылки на необходимый функционал.