## ИЗ PANDAS В JSON

Cоздадим JSON-файл из CSV-файла.
Начнём с чтения файла и создания DataFrame на его основе:
```python
# Создаём DataFrame, читаем данные из файла в переменную df
df = pd.read_csv('recipes.csv')
```
Теперь, используя только данные из этого файла, нам нужно в точности воссоздать структуру исходного *JSON*-файла. Мы помним, что после **десериализации** данные представляли собой список, состоящий из словарей. В каждом словаре хранилась информация о рецепте одного блюда. Каждый словарь состоял из трёх пар "ключ-значение". Первая пара содержала название кухни, к которой относилось блюдо, вторая — *id* блюда, и третья — список ингредиентов входящих в состав блюда.

Напишем код для создания списка *id* всех блюд, нужны только уникальные значения представленных в *DataFrame*. Результирующий список занесите в переменную *ids*.

```python
import pandas as pd

df = pd.read_csv('recipes.csv') # Читаем содержмиое файла и создаем объект df
ids = list(df['id'].unique()) # Создаем список уникальных значений id блюд
```
Напишем код для создания списка ингредиентов всех блюд, представленных в *DataFrame*. Результирующий список занесите в переменную *ingredients*.

```python
import pandas as pd
# Читаем содержимое файла и создаем объект df
df = pd.read_csv('recipes.csv') 
# Создаем список уникальных значений ингредиентов
ingredients = list(df.columns)[3:] 
# Выводим результат на экран:
print(ingredients)

# [] - результат вывода кода
```

Теперь мы можем использовать подготовленные списки *ids* и *ingredients* для непосредственного создания *JSON*-структуры.

Каждый словарь будет состоять из трёх пар "ключ-значение", при этом в качестве значений будут выступать:

* целое число (id блюда);
* строковая величина (тип кухни);
* список строковых величин (перечень ингредиентов).

Для этого:
1. Создадим пустой список new_recipes — для хранения итоговой структуры
2. Создадим список ids — для хранения id всех блюд
3. Создадим список ingredients — для хранения названий всех ингредиентов
4. Напишем код функции *make_list()*, которая принимает на вход строку *DataFrame* **df**, содержащую полные данные об одном блюде, и возвращает перечень ингредиентов, входящих в состав этого блюда в виде списка
5. Организовать цикл с параметром, в котором будут перебираться элементы списка *ids*. В результате в процессе прохождения цикла параметр должен принять значение *id* каждого блюда
6. На каждом шаге цикла создать словарь, содержащий три пары "ключ-значение":

   * ключу *"id"* присвоить текущее значение параметра цикла как целого числа;
   * ключу *"cuisine"* присвоить значение соответствующей кухни, которое мы получим, применив фильтр по текущему *id* к *DataFrame df*;
   * ключу *"ingredients"* присвоить значение списка, воспользовавшись функцией *make_list()*, созданной на первом шаге алгоритма.

7. Каждый созданный словарь добавить к списку *new_recipes*:

```python
import pandas as pd
# Читаем содержимое файла и создаем объект df
df = pd.read_csv('recipes.csv') 
# Создаем список уникальных значений id блюд
ids = list(df['id'].unique()) 

# Создаем пустой список для хранения итоговой структуры
new_recipes = []

# Организуем цикл с параметром current_id
for current_id in ids: 
    # Получаем значение соответствующей кухни, применив фильтр по текущему значению параметра цикла к DataFrame
    cuisine = df[df['id'] == current_id]['cuisine'].iloc[0] 
    # Получаем перечень ингредиентов, входящих в состав текущего блюда
    current_ingredients = make_list(df[df['id'] == current_id]) 
    # Создаем текущий словарь
    current_recipe = {'cuisine': cuisine, 'id': int(current_id), 'ingredients': current_ingredients}
    # Добавляем созданный словарь к списку
    new_recipes.append(current_recipe)
df = pd.read_csv('recipes.csv')
# Создаем список уникальных значений ингредиентов
ingredients = list(df.columns)[3:]
```
Напишем код функции *make_list()*, которая принимает на вход одну строку DataFrame, содержащую данные об одном рецепте, и возвращает перечень ингредиентов этого блюда в виде списка.

Функция *make_list()* должна принимать только один аргумент - *row*. Это будет строка датафрейма.
```python
# Читаем содержимое файла и создаем объект df
df = pd.read_csv('recipes')
# Создаем список уникальных значений ингредиентов
ingredients = list(df.columns)[3:]

# Определяем имя функции и передаваемые аргументы
def make_list(row):
    # Создаем пустой список ингредиентов текущего блюда
    ingredient_list=[]
    # Последовательно перебираем ингредиенты из реестра
    for ingredient in ingredients:
        # Если текущий ингредиент входит в состав текущего блюда
        if row[ingredient].item()==1:
            # Добавляем ингредиент в список ингредиентов текущего блюда
            ingredient_list.append(ingredient)
    # Возвращаем сформированный список ингредиентов        
    return ingredient_list
# Передаем в качестве аргумента строку датафрейма
row = df.iloc[1]

# Выводим результат кода на экран 
print(make_list(row = df.iloc[1]))
```

Выполним **сериализацию** списка *new_recipes* и запишем полученные данные в файл.

Для сериализации  используем функцию *dumps()*, которой в качестве параметра передадим список *new_recipes*. Запись в файл осуществляется с помощью метода *write()*. Предварительно файл необходимо открыть для записи с помощью функции *open()* c параметром 'w' (от англ. *write*, рус. *писать*):

```python
# Импорт модуля json
import json
# Функция dumps() модуля json сериализирует объект Python в строку формата JSON
new_recipes = json.dumps(new_recipes)
# Откроем файл new_recipes.json для записи
with open('data/new_recipes.json','w') as write_file:
    # Записываем содержимое подготовленные данные в файл
    write_file.write(new_recipes)
```